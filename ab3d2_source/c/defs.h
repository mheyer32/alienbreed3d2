#ifndef DEFS_H
#define DEFS_H

#include <exec/types.h>

/**
 * C structure definitions to match the assembler ones in defs.i
 *
 * DO NOT EDIT THIS FILE WITHOUT MAKING THE CORRESPONDING CHANGES IN defs.i
 */

#define MAX_LEVEL_OBJ_DIST_COUNT    (256+32)
#define MAX_OBJS_IN_LINE_COUNT      400
#define LVL_OBJ_DEFINITION_SIZE     64

#define NUM_LEVELS          16
#define NUM_BULLET_DEFS     20
#define NUM_GUN_DEFS        10
#define NUM_ALIEN_DEFS      20
#define NUM_OBJECT_DEFS     30
#define NUM_SFX             64
#define NUM_WALL_TEXTURES   16

/*
 * These structures are managed by the assembler side and the alignment constraints are to preven the compiler
 * from padding them further for alignment purposes. It does not mean that the structures themselves are only
 * aligned to a 2 byte boundary,
 */
typedef struct {
    /* Note that we have separate named fields here, but we regard the struct as equivalent to UWORD[]*/
    UWORD ic_Health;
    UWORD ic_JetpackFuel;
    UWORD ic_AmmoCounts[NUM_BULLET_DEFS];
}  __attribute__((packed)) __attribute__ ((aligned (2))) InventoryConsumables;

typedef struct {
    /* Note that we have separate named fields here, but we regard the struct as equivalent to UWORD[]*/
    UWORD ii_Shield;
    UWORD ii_Jetpack;
    UWORD ii_Weapons[NUM_GUN_DEFS];
} __attribute__((packed)) __attribute__ ((aligned (2))) InventoryItems;

typedef struct {
    InventoryConsumables inv_Consumables;
    InventoryItems       inv_Items;
} __attribute__((packed)) __attribute__ ((aligned (2))) Inventory;

typedef struct {
    LONG o_XPos;
    LONG o_ZPos;
    LONG o_YPos;
    UWORD o_ZoneID;
    UWORD o_Unused;
    UBYTE o_TypeID;
    UBYTE o_SeePlayer;
} ObjBase;

#endif // DEFS_H
